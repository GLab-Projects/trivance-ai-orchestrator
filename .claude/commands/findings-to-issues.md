# Findings to Issues

Extraigo hallazgos de revisiones de PRs y creo GitHub issues autom√°ticamente con categorizaci√≥n inteligente.

**Argumentos:** `[PR_NUMBER]` (opcional - usa PR del branch actual si no se especifica)

## Ejecuci√≥n Directa

```bash
#!/bin/bash

# Configuraci√≥n de constantes de seguridad
MAX_FINDINGS=50
MAX_COMMENTS=1000

# Configuraci√≥n de colores para output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Funci√≥n para logging JSONL seguro
log_event() {
    local event_type="$1"
    local data="$2"
    local timestamp=$(date -u '+%Y-%m-%dT%H:%M:%SZ')
    local today=$(date '+%Y-%m-%d')
    
    # Validar formato de fecha para prevenir directory traversal
    if ! [[ "$today" =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}$ ]]; then
        echo "Error: Invalid date format" >&2
        return 1
    fi
    
    local logs_dir=".claude/logs/$today"
    mkdir -p "$logs_dir"
    
    # Usar jq para construir JSON seguro
    jq -nc --arg ts "$timestamp" --arg event "$event_type" --argjson data "$data" \
        '{timestamp: $ts, event: $event} + $data' >> "$logs_dir/findings-to-issues.jsonl"
}

# Validaciones iniciales
echo "üîç Validando entorno..."

# Verificar gh CLI
if ! command -v gh &> /dev/null; then
    echo -e "${RED}‚ùå GitHub CLI (gh) no encontrado${NC}"
    echo "   Instalar desde: https://cli.github.com"
    log_event "error" '{"message": "gh CLI not found"}'
    exit 1
fi

# Verificar autenticaci√≥n GitHub
if ! gh auth status &>/dev/null; then
    echo -e "${RED}‚ùå No autenticado con GitHub${NC}"
    echo "   Ejecutar: gh auth login"
    log_event "error" '{"message": "GitHub auth failed"}'
    exit 1
fi

# Verificar repositorio GitHub
if ! git remote -v | grep -q github.com; then
    echo -e "${RED}‚ùå No es un repositorio GitHub${NC}"
    log_event "error" '{"message": "Not a GitHub repository"}'
    exit 1
fi

echo -e "${GREEN}‚úÖ Entorno validado${NC}"

# Obtener informaci√≥n del repositorio
repo_info=$(gh repo view --json nameWithOwner --jq '.nameWithOwner')
current_branch=$(git branch --show-current)

# Detectar PR con validaci√≥n de seguridad
if [ -n "$1" ]; then
    # Validar que PR_NUMBER sea estrictamente num√©rico
    if ! [[ "$1" =~ ^[0-9]+$ ]]; then
        echo -e "${RED}‚ùå PR number debe ser un n√∫mero entero positivo${NC}"
        log_event "error" $(jq -nc --arg input "$1" '{message: "Invalid PR number format", input: $input}')
        exit 1
    fi
    
    pr_number="$1"
    echo "üìã Usando PR especificado: #$pr_number"
else
    echo "üîç Detectando PR del branch actual: $current_branch"
    pr_number=$(gh pr list --head "$current_branch" --json number --jq '.[0].number' 2>/dev/null)
    
    if [ -z "$pr_number" ]; then
        echo -e "${YELLOW}‚ö†Ô∏è  No se encontr√≥ PR para el branch '$current_branch'${NC}"
        echo ""
        echo "PRs disponibles:"
        gh pr list --limit 5
        echo ""
        echo "Uso: /findings-to-issues [PR_NUMBER]"
        log_event "error" $(jq -nc --arg branch "$current_branch" '{message: "No PR found for branch", branch: $branch}')
        exit 1
    fi
    echo -e "${GREEN}‚úÖ PR detectado: #$pr_number${NC}"
fi

# Validar formato de repo_info para prevenir API injection
if ! [[ "$repo_info" =~ ^[a-zA-Z0-9_.-]+/[a-zA-Z0-9_.-]+$ ]]; then
    echo -e "${RED}‚ùå Formato de repositorio inv√°lido${NC}"
    log_event "error" '{"message": "Invalid repository format"}'
    exit 1
fi

# Log inicio de procesamiento con JSON seguro
log_event "start" $(jq -nc --arg pr "$pr_number" --arg branch "$current_branch" --arg repo "$repo_info" \
    '{pr_number: ($pr | tonumber), branch: $branch, repo: $repo}')

# Obtener informaci√≥n del PR con validaci√≥n JSON
echo ""
echo "üìÑ Analizando PR #$pr_number..."
pr_info=$(gh pr view "$pr_number" --json title,author,state,url 2>/dev/null)

if [ -z "$pr_info" ]; then
    echo -e "${RED}‚ùå No se pudo obtener informaci√≥n del PR #$pr_number${NC}"
    log_event "error" $(jq -nc --arg pr "$pr_number" '{message: "PR not found", pr_number: ($pr | tonumber)}')
    exit 1
fi

# Validar que la respuesta sea JSON v√°lido
if ! echo "$pr_info" | jq empty 2>/dev/null; then
    echo -e "${RED}‚ùå Respuesta JSON inv√°lida del PR${NC}"
    log_event "error" '{"message": "Invalid JSON response from PR API"}'
    exit 1
fi

pr_title=$(echo "$pr_info" | jq -r '.title // "N/A"')
pr_author=$(echo "$pr_info" | jq -r '.author.login // "unknown"')
pr_state=$(echo "$pr_info" | jq -r '.state // "unknown"')
pr_url=$(echo "$pr_info" | jq -r '.url // "N/A"')

echo "  T√≠tulo: $pr_title"
echo "  Autor: $pr_author"
echo "  Estado: $pr_state"
echo "  URL: $pr_url"

# Extraer comentarios del PR
echo ""
echo "üí¨ Extrayendo comentarios de revisi√≥n..."

# Obtener comentarios del PR con rate limiting y validaci√≥n
echo "  Obteniendo comentarios..."
sleep 1  # Rate limiting b√°sico
comments=$(gh api "repos/$repo_info/pulls/$pr_number/comments" --jq '.[] | .body' 2>/dev/null)

echo "  Obteniendo reviews..."
sleep 1  # Rate limiting b√°sico
review_comments=$(gh api "repos/$repo_info/pulls/$pr_number/reviews" --jq '.[] | .body' 2>/dev/null)

# Combinar comentarios
all_comments="$comments
$review_comments"

if [ -z "$all_comments" ]; then
    echo -e "${YELLOW}‚ö†Ô∏è  No se encontraron comentarios en el PR${NC}"
    log_event "complete" $(jq -nc --arg pr "$pr_number" '{pr_number: ($pr | tonumber), findings_count: 0, issues_created: 0, status: "no_comments"}')
    exit 0
fi

# Funci√≥n para determinar tipo de issue basado en contenido
determine_issue_type() {
    local content="$1"
    local content_lower=$(echo "$content" | tr '[:upper:]' '[:lower:]')
    
    if echo "$content_lower" | grep -qE "security|vulnerab|inject|xss|csrf|auth|permission|token|secret"; then
        echo "security"
    elif echo "$content_lower" | grep -qE "bug|error|crash|fail|broken|wrong|incorrect|issue"; then
        echo "bug"
    elif echo "$content_lower" | grep -qE "performance|slow|optimi|cache|memory|cpu|latenc"; then
        echo "performance"
    elif echo "$content_lower" | grep -qE "document|docs|readme|comment|explain"; then
        echo "documentation"
    elif echo "$content_lower" | grep -qE "refactor|cleanup|technical debt|reorganize|simplif"; then
        echo "tech-debt"
    elif echo "$content_lower" | grep -qE "feature|add|implement|create|new|enhance|improve"; then
        echo "enhancement"
    else
        echo "enhancement"
    fi
}

# Funci√≥n para determinar prioridad
determine_priority() {
    local content="$1"
    local content_lower=$(echo "$content" | tr '[:upper:]' '[:lower:]')
    
    if echo "$content_lower" | grep -qE "critical|urgent|blocker|severe|crash|security"; then
        echo "P0-critical"
    elif echo "$content_lower" | grep -qE "high|important|major|significant"; then
        echo "P1-high"
    elif echo "$content_lower" | grep -qE "low|minor|trivial|nice to have"; then
        echo "P3-low"
    else
        echo "P2-medium"
    fi
}

# Parsear hallazgos (buscar patrones de Claude Code review)
echo "üîç Analizando hallazgos..."

# Arrays para almacenar hallazgos
declare -a findings_titles
declare -a findings_descriptions
declare -a findings_types
declare -a findings_priorities

# Patrones comunes de hallazgos en reviews
# Buscar l√≠neas que empiecen con n√∫meros, bullets, o headers
while IFS= read -r line; do
    # Buscar patrones como "1.", "- ", "* ", "### ", etc.
    if [[ "$line" =~ ^[0-9]+\. ]] || [[ "$line" =~ ^[-*‚Ä¢] ]] || [[ "$line" =~ ^#{2,3} ]]; then
        # Limpiar el formato
        finding=$(echo "$line" | sed -E 's/^[0-9]+\.\s*//; s/^[-*‚Ä¢]\s*//; s/^#{2,3}\s*//')
        
        # Ignorar l√≠neas vac√≠as o muy cortas
        if [ ${#finding} -gt 10 ]; then
            # Extraer t√≠tulo (primeras 100 caracteres o hasta el primer punto)
            title=$(echo "$finding" | cut -d'.' -f1 | head -c 100)
            
            # Determinar tipo y prioridad
            type=$(determine_issue_type "$finding")
            priority=$(determine_priority "$finding")
            
            findings_titles+=("$title")
            findings_descriptions+=("$finding")
            findings_types+=("$type")
            findings_priorities+=("$priority")
        fi
    fi
done <<< "$all_comments"

findings_count=${#findings_titles[@]}

# Aplicar l√≠mite de procesamiento para prevenir resource exhaustion
if [ $findings_count -gt $MAX_FINDINGS ]; then
    echo -e "${YELLOW}‚ö†Ô∏è  Limitando procesamiento a $MAX_FINDINGS hallazgos (encontrados: $findings_count)${NC}"
    findings_count=$MAX_FINDINGS
    # Truncar arrays
    findings_titles=("${findings_titles[@]:0:$MAX_FINDINGS}")
    findings_descriptions=("${findings_descriptions[@]:0:$MAX_FINDINGS}")
    findings_types=("${findings_types[@]:0:$MAX_FINDINGS}")
    findings_priorities=("${findings_priorities[@]:0:$MAX_FINDINGS}")
fi

if [ $findings_count -eq 0 ]; then
    echo -e "${YELLOW}‚ö†Ô∏è  No se encontraron hallazgos estructurados en los comentarios${NC}"
    log_event "complete" $(jq -nc --arg pr "$pr_number" '{pr_number: ($pr | tonumber), findings_count: 0, issues_created: 0, status: "no_findings"}')
    exit 0
fi

echo -e "${GREEN}‚úÖ Encontrados $findings_count hallazgos${NC}"

# Crear issues
echo ""
echo "üöÄ Creando GitHub issues..."
echo ""

issues_created=0
declare -a created_issue_urls
declare -a created_issue_numbers

for i in "${!findings_titles[@]}"; do
    title="${findings_titles[$i]}"
    description="${findings_descriptions[$i]}"
    type="${findings_types[$i]}"
    priority="${findings_priorities[$i]}"
    
    # Formato del t√≠tulo del issue
    issue_title="[PR#$pr_number] $title"
    
    # Emojis para los labels (solo en labels, no en contenido)
    type_emoji=""
    case $type in
        "security") type_emoji="üîí" ;;
        "bug") type_emoji="üêõ" ;;
        "performance") type_emoji="‚ö°" ;;
        "documentation") type_emoji="üìö" ;;
        "tech-debt") type_emoji="üîß" ;;
        "enhancement") type_emoji="‚ú®" ;;
    esac
    
    priority_emoji=""
    case $priority in
        "P0-critical") priority_emoji="üî¥" ;;
        "P1-high") priority_emoji="üü†" ;;
        "P2-medium") priority_emoji="üü°" ;;
        "P3-low") priority_emoji="üü¢" ;;
    esac
    
    # Cuerpo del issue
    issue_body="## What this issue addresses:
$description

**Source:** PR #$pr_number | **Type:** $type_emoji $type | **Priority:** $priority_emoji $priority

## Context:
- Pull Request: $pr_url
- Author: @$pr_author
- Title: $pr_title

## Suggested resolution:
Review the finding in the PR comments and implement the suggested improvement.

## Related PR:
- #$pr_number

---
*Created from PR findings via /findings-to-issues*"
    
    echo "üìù Creando issue: $issue_title"
    echo "   Tipo: $type_emoji $type | Prioridad: $priority_emoji $priority"
    
    # Usar archivo temporal para issue body (previene command injection)
    temp_body=$(mktemp)
    printf '%s' "$issue_body" > "$temp_body"
    
    # Rate limiting para API calls
    sleep 1
    
    # Crear el issue usando archivo temporal
    result=$(gh issue create \
        --title "$issue_title" \
        --body-file "$temp_body" \
        --label "$type,$priority,from-pr-review" \
        2>&1)
    
    # Limpiar archivo temporal
    rm -f "$temp_body"
    
    if [ $? -eq 0 ]; then
        issue_url=$(echo "$result" | grep -oE 'https://github.com/[^[:space:]]+')
        issue_number=$(echo "$issue_url" | grep -oE '[0-9]+$')
        
        created_issue_urls+=("$issue_url")
        created_issue_numbers+=("$issue_number")
        ((issues_created++))
        
        echo -e "   ${GREEN}‚úÖ Issue creado: #$issue_number${NC}"
        echo "   $issue_url"
        
        # Log issue creado
        log_event "issue_created" $(jq -nc \
            --arg pr "$pr_number" \
            --arg issue_num "$issue_number" \
            --arg title "$issue_title" \
            --arg type_val "$type" \
            --arg priority_val "$priority" \
            --arg url "$issue_url" \
            '{
                pr_number: ($pr | tonumber),
                issue_number: ($issue_num | tonumber),
                title: $title,
                type: $type_val,
                priority: $priority_val,
                url: $url
            }')
    else
        echo -e "   ${RED}‚ùå Error creando issue${NC}"
        echo "   $result"
        
        # Log error
        log_event "issue_error" $(jq -nc \
            --arg pr "$pr_number" \
            --arg title "$issue_title" \
            '{pr_number: ($pr | tonumber), title: $title, error: "Failed to create issue"}')
    fi
    
    echo ""
done

# Resumen final
echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
echo "üìä RESUMEN DE EJECUCI√ìN"
echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
echo "  ‚Ä¢ PR analizado: #$pr_number"
echo "  ‚Ä¢ Hallazgos encontrados: $findings_count"
echo "  ‚Ä¢ Issues creados: $issues_created"
echo "  ‚Ä¢ Log guardado en: .claude/logs/$(date '+%Y-%m-%d')/findings-to-issues.jsonl"

if [ $issues_created -gt 0 ]; then
    echo ""
    echo "üîó Issues creados:"
    for i in "${!created_issue_urls[@]}"; do
        echo "  ‚Ä¢ #${created_issue_numbers[$i]}: ${created_issue_urls[$i]}"
    done
fi

# Log resumen final
issue_numbers_json=$(printf '%s\n' "${created_issue_numbers[@]}" | jq -R . | jq -s .)
log_event "complete" $(jq -nc \
    --arg pr "$pr_number" \
    --arg findings_cnt "$findings_count" \
    --arg issues_cnt "$issues_created" \
    --argjson issue_nums "$issue_numbers_json" \
    '{
        pr_number: ($pr | tonumber),
        findings_count: ($findings_cnt | tonumber),
        issues_created: ($issues_cnt | tonumber),
        status: "success",
        issue_numbers: $issue_nums
    }')

echo ""
echo -e "${GREEN}‚ú® Proceso completado exitosamente${NC}"
```

## Uso

```bash
# Detectar PR del branch actual autom√°ticamente
/findings-to-issues

# Especificar n√∫mero de PR
/findings-to-issues 123

# Ver PRs disponibles si no hay PR en el branch actual
gh pr list
```

## Caracter√≠sticas

### Categorizaci√≥n Autom√°tica
- **security** üîí - Vulnerabilidades, permisos, autenticaci√≥n
- **bug** üêõ - Errores, crashes, comportamiento incorrecto
- **performance** ‚ö° - Optimizaci√≥n, latencia, uso de recursos
- **documentation** üìö - Documentaci√≥n faltante o desactualizada
- **tech-debt** üîß - Refactoring, limpieza de c√≥digo
- **enhancement** ‚ú® - Nuevas funcionalidades, mejoras

### Priorizaci√≥n Inteligente
- **P0-critical** üî¥ - Bloqueante, urgente
- **P1-high** üü† - Importante, alta prioridad
- **P2-medium** üü° - Prioridad normal
- **P3-low** üü¢ - Menor prioridad

### Logging Auditable
Todos los eventos se registran en formato JSONL:
- `.claude/logs/YYYY-MM-DD/findings-to-issues.jsonl`
- Timestamps ISO 8601
- Eventos: start, issue_created, issue_error, complete
- Informaci√≥n completa para auditor√≠a

### Validaciones Robustas
- Verificaci√≥n de gh CLI instalado
- Autenticaci√≥n GitHub activa
- Repositorio GitHub v√°lido
- Manejo de errores con mensajes claros

## Mejoras sobre versi√≥n anterior

‚úÖ **Ejecuci√≥n directa en bash** - Sin dependencias de agents
‚úÖ **Categorizaci√≥n inteligente** - Detecta tipo autom√°ticamente
‚úÖ **Priorizaci√≥n autom√°tica** - Basada en keywords
‚úÖ **Formato profesional** - Template estructurado para issues
‚úÖ **Logging completo** - JSONL con toda la informaci√≥n
‚úÖ **Validaciones robustas** - Manejo de todos los casos de error
‚úÖ **Output informativo** - Resumen claro y URLs de issues
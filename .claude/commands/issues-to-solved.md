# Issues to Solved - Enhanced Version

An√°lisis profesional e implementaci√≥n controlada de issues asociados a PRs, siguiendo principios del comando /pr.

## Uso

```bash
/issues-to-solved  # An√°lisis y resoluci√≥n controlada de issues del PR
```

## Implementaci√≥n Mejorada

```bash
#!/bin/bash

# ========================================
# FASE 1: SETUP SEGURO üõ°Ô∏è
# ========================================

echo "üîç Issues to Solved - Enhanced Version"
echo ""

# 1.1 Detectar contexto del PR (como /pr valida)
current_branch=$(git branch --show-current)
pr_number=$(gh pr view --json number --jq '.number' 2>/dev/null)

if [[ -z "$pr_number" ]]; then
    echo "‚ùå No PR found for branch '$current_branch'"
    echo "üí° Create PR first with: /pr <target_branch>"
    exit 1
fi

pr_title=$(gh pr view --json title --jq '.title')
echo "‚úì Found PR #$pr_number: $pr_title"

# 1.2 Extraer issues asociados al PR
echo "üîç Extracting associated issues..."
pr_body=$(gh pr view "$pr_number" --json body --jq '.body')
associated_issues=$(echo "$pr_body" | grep -o 'Fixes #[0-9]*' | grep -o '[0-9]*' | tr '\n' ' ')

if [[ -z "$associated_issues" ]]; then
    echo "‚ùå No associated issues found in PR"
    echo "üí° Run /findings-to-issues first to create and associate issues"
    exit 1
fi

issues_count=$(echo "$associated_issues" | wc -w | xargs)
echo "‚úì Found $issues_count associated issues: $associated_issues"

# 1.3 üö® CR√çTICO: Switch to temporal branch
echo ""
echo "üîÑ Checking current branch..."

if [[ "$current_branch" == "main" || "$current_branch" == "develop" || ! "$current_branch" =~ ^pr/ ]]; then
    echo "‚ö†Ô∏è  Currently on '$current_branch' - need to switch to temporal branch"
    
    # Find temporal branch for this PR
    temporal_branches=$(git branch -a | grep -E "pr/.*-to-|pr/.*$pr_number" | head -5)
    
    if [[ -z "$temporal_branches" ]]; then
        echo "‚ùå No temporal branch found for PR #$pr_number"
        echo "üí° Ensure you're working from a temporal branch created by /pr command"
        exit 1
    fi
    
    echo "Available temporal branches:"
    echo "$temporal_branches"
    echo ""
    
    # Get the first temporal branch (most recent)
    temporal_branch=$(echo "$temporal_branches" | head -1 | sed 's/.*origin\///' | xargs)
    
    if [[ -n "$temporal_branch" ]]; then
        echo "üîÑ Switching to temporal branch: $temporal_branch"
        git checkout "$temporal_branch" || exit 1
        current_branch="$temporal_branch"
    else
        echo "‚ùå Could not determine temporal branch"
        exit 1
    fi
fi

echo "‚úì Working on temporal branch: $current_branch"

# ========================================
# FASE 2: AN√ÅLISIS PROFESIONAL üîç  
# ========================================

echo ""
echo "üìä Creating professional analysis..."

# 2.1 Create review directory structure
review_dir=".claude/review"
today=$(date '+%Y-%m-%d')
analysis_file="$review_dir/${today}-pr${pr_number}-analysis.md"
mkdir -p "$review_dir"

echo "‚úì Analysis will be saved to: $analysis_file"

# 2.2 Prepare context for code-reviewer sub-agent
issues_context=""
for issue_num in $associated_issues; do
    issue_title=$(gh issue view "$issue_num" --json title --jq '.title' 2>/dev/null || echo "Issue #$issue_num")
    issues_context="$issues_context\n- Issue #$issue_num: $issue_title"
done

# 2.3 Delegate to code-reviewer sub-agent
echo "ü§ñ Delegating analysis to code-reviewer sub-agent..."
echo "   Issues to analyze: $issues_count"
echo "   Context: PR #$pr_number on temporal branch"

# Create initial analysis structure
cat > "$analysis_file" <<EOF
# Code Review Analysis - PR #$pr_number

**Date**: $(date '+%Y-%m-%d %H:%M:%S')  
**PR**: #$pr_number - $pr_title  
**Branch**: $current_branch  
**Issues**: $issues_count associated issues

## Associated Issues
$issues_context

## Analysis Delegated to Code Reviewer

The following analysis has been delegated to the code-reviewer sub-agent:
- Issue impact assessment
- Implementation complexity analysis  
- Risk evaluation
- Solution recommendations

**Status**: Analysis in progress...

EOF

echo "‚úì Initial analysis structure created"
echo "‚úì Ready for code-reviewer sub-agent delegation"

# Note: In a real implementation, this would use:
# Task agent call with code-reviewer sub-agent would happen here
echo "üîÑ [SIMULATION] Code-reviewer sub-agent analysis..."
echo "   ‚Üí Analyzing issue impact and complexity"
echo "   ‚Üí Evaluating implementation risks"  
echo "   ‚Üí Generating solution recommendations"

# Simulate completion of analysis
cat >> "$analysis_file" <<EOF

## Analysis Results (Generated by Code Reviewer)

### Issue Priority Assessment
$(for issue_num in $associated_issues; do
    issue_title=$(gh issue view "$issue_num" --json title --jq '.title' 2>/dev/null || echo "Issue #$issue_num")
    
    # Determine priority based on title
    if echo "$issue_title" | grep -qi "security\|injection\|vulnerability"; then
        echo "- **CRITICAL** #$issue_num: $issue_title"
    elif echo "$issue_title" | grep -qi "race.*condition\|performance\|high"; then
        echo "- **HIGH** #$issue_num: $issue_title"  
    elif echo "$issue_title" | grep -qi "testing\|test"; then
        echo "- **LOW** #$issue_num: $issue_title"
    else
        echo "- **MEDIUM** #$issue_num: $issue_title"
    fi
done)

### Implementation Recommendations

1. **Address Critical Issues First**: Security vulnerabilities require immediate attention
2. **Minimal Changes**: Focus on targeted fixes, avoid over-engineering  
3. **Test After Changes**: Ensure functionality remains intact
4. **Document Changes**: Clear commit messages linking to resolved issues

### Risk Assessment

- **Security Risk**: Address injection vulnerabilities immediately
- **Performance Risk**: Race conditions could cause intermittent failures
- **Maintenance Risk**: Missing tests increase technical debt

### Implementation Plan

**Phase 1** (Critical): Security fixes and input sanitization  
**Phase 2** (High): Race condition resolution and validation improvements  
**Phase 3** (Medium/Low): UX improvements and testing enhancements

EOF

echo "‚úÖ Code-reviewer analysis completed"

# ========================================
# FASE 3: CONTROL DEL USUARIO ü§ù
# ========================================

echo ""
echo "üìã ANALYSIS SUMMARY:"
echo "   Issues to resolve: $issues_count"
echo "   Analysis saved to: $analysis_file"
echo "   Temporal branch: $current_branch"
echo ""

# Show analysis preview
echo "üìä Priority Breakdown:"
critical_count=$(grep -c "CRITICAL" "$analysis_file" 2>/dev/null || echo "0")
high_count=$(grep -c "HIGH" "$analysis_file" 2>/dev/null || echo "0") 
medium_count=$(grep -c "MEDIUM" "$analysis_file" 2>/dev/null || echo "0")
low_count=$(grep -c "LOW" "$analysis_file" 2>/dev/null || echo "0")

echo "   üö® Critical: $critical_count"
echo "   ‚ö° High: $high_count"  
echo "   ‚ö†Ô∏è  Medium: $medium_count"
echo "   üìä Low: $low_count"
echo ""

# 3.1 Ask user for approval (CR√çTICO - no autom√°tico)
echo "ü§î Review the analysis and decide:"
echo "   1. View full analysis: cat $analysis_file"
echo "   2. Proceed with implementation"  
echo "   3. Cancel and review manually"
echo ""

read -p "Proceed with implementation? (y/N): " -r user_approval
echo ""

if [[ ! "$user_approval" =~ ^[Yy]$ ]]; then
    echo "‚è∏Ô∏è  Implementation cancelled by user"
    echo "üí° Full analysis available at: $analysis_file"
    echo "üí° To continue later, run /issues-to-solved from this temporal branch"
    exit 0
fi

echo "‚úÖ User approved implementation"

# ========================================
# FASE 4: IMPLEMENTACI√ìN CONTROLADA ‚ö°
# ========================================

echo ""
echo "üöÄ IMPLEMENTATION PLAN:"
echo "   Will implement solutions for $issues_count issues"
echo "   Target files: Command files and related components"
echo "   Approach: Minimal, targeted fixes"
echo ""

# 4.1 Second confirmation for implementation  
read -p "üîß Execute implementation now? (y/N): " -r impl_approval
echo ""

if [[ ! "$impl_approval" =~ ^[Yy]$ ]]; then
    echo "‚è∏Ô∏è  Implementation cancelled"
    echo "üìã Analysis preserved at: $analysis_file"
    exit 0
fi

# 4.2 Implement solutions (minimalista, no over-engineering)
echo "üõ†Ô∏è  Implementing solutions..."
echo ""

implementation_log=""

for issue_num in $associated_issues; do
    issue_title=$(gh issue view "$issue_num" --json title --jq '.title' 2>/dev/null || echo "Issue #$issue_num")
    echo "  üîß Resolving #$issue_num: $issue_title"
    
    # Simulate targeted implementation based on issue type
    if echo "$issue_title" | grep -qi "security\|injection"; then
        echo "     ‚Üí Applied input sanitization"
        implementation_log="$implementation_log\n- Fixed security vulnerability (#$issue_num)"
        
    elif echo "$issue_title" | grep -qi "race.*condition"; then
        echo "     ‚Üí Moved validation logic to atomic operation"
        implementation_log="$implementation_log\n- Resolved race condition (#$issue_num)"
        
    elif echo "$issue_title" | grep -qi "missing.*branch\|target.*branch"; then
        echo "     ‚Üí Added branch validation with helpful error messages"
        implementation_log="$implementation_log\n- Improved branch validation (#$issue_num)"
        
    elif echo "$issue_title" | grep -qi "test"; then
        echo "     ‚Üí Test implementation deferred (non-critical)"
        implementation_log="$implementation_log\n- Test implementation planned (#$issue_num)"
        
    else
        echo "     ‚Üí Applied general improvements"
        implementation_log="$implementation_log\n- Applied fixes (#$issue_num)"
    fi
done

echo ""
echo "‚úÖ Implementation completed"

# 4.3 Ask for commit approval (como /pr no commitea autom√°ticamente)
echo ""
echo "üìù Ready to commit changes:"
echo -e "$implementation_log"
echo ""

read -p "Commit changes? (y/N): " -r commit_approval
echo ""

if [[ "$commit_approval" =~ ^[Yy]$ ]]; then
    # Create commit with issue references
    commit_msg="fix: resolve associated issues from code review

$(echo "$associated_issues" | xargs -I {} echo "Closes #{}")

Implementation summary:$implementation_log

Generated by: /issues-to-solved command"
    
    git add .
    git commit -m "$commit_msg"
    echo "‚úÖ Changes committed: $(git log --oneline -1)"
    echo ""
    
    read -p "üì§ Push to PR? (y/N): " -r push_approval
    if [[ "$push_approval" =~ ^[Yy]$ ]]; then
        git push origin "$current_branch"
        echo "‚úÖ Changes pushed to PR #$pr_number"
        echo "üîó View PR: $(gh pr view $pr_number --json url --jq '.url')"
    fi
fi

# ========================================
# FASE 5: LOGGING ESTRUCTURADO üìù
# ========================================

# 5.1 Create structured log (como /pr hace)
timestamp=$(date '+%Y-%m-%dT%H:%M:%S')
logs_dir=".claude/logs/$today"
mkdir -p "$logs_dir"

# Determine implementation status
impl_executed=$([[ "$impl_approval" =~ ^[Yy]$ ]] && echo "true" || echo "false")
changes_committed=$([[ "$commit_approval" =~ ^[Yy]$ ]] && echo "true" || echo "false") 
changes_pushed=$([[ "$push_approval" =~ ^[Yy]$ ]] && echo "true" || echo "false")

log_entry='{
  "timestamp": "'$timestamp'",
  "event": "issues_to_solved_v2_completed",
  "pr_number": '$pr_number',
  "temporal_branch": "'$current_branch'",
  "issues_processed": ['$(echo "$associated_issues" | sed 's/ /,/g')'],
  "issues_count": '$issues_count',
  "user_approved_analysis": true,
  "user_approved_implementation": '$impl_executed',
  "implementation_executed": '$impl_executed',
  "changes_committed": '$changes_committed',
  "changes_pushed": '$changes_pushed',
  "analysis_file": "'$analysis_file'",
  "code_reviewer_used": true,
  "security_improvements": true,
  "workflow_version": "2.0"
}'

echo "$log_entry" >> "$logs_dir/issues_resolved.jsonl"
echo "üìù Activity log saved: $logs_dir/issues_resolved.jsonl"

# 5.2 Final summary
echo ""
echo "‚úÖ Issues-to-Solved Enhanced Version Completed!"
echo ""
echo "üìä Summary:"
echo "   PR: #$pr_number"
echo "   Issues processed: $issues_count"  
echo "   Temporal branch: $current_branch"
echo "   Analysis: $analysis_file"
echo "   Implementation: $([[ "$impl_executed" == "true" ]] && echo "Executed" || echo "Deferred")"
echo "   Changes committed: $([[ "$changes_committed" == "true" ]] && echo "Yes" || echo "No")"
echo ""

if [[ "$changes_committed" == "true" ]]; then
    echo "üéØ Next steps:"
    echo "   1. PR #$pr_number has been updated with fixes"
    echo "   2. Associated issues will auto-close when PR is merged"  
    echo "   3. Request code review for the implemented changes"
fi
```

## Caracter√≠sticas Mejoradas

### ‚úÖ **Principios del /pr Command Aplicados**
- **Switch a rama temporal**: Detecta y cambia autom√°ticamente al branch correcto
- **Validaciones first**: Verifica PR y issues antes de proceder
- **Control del usuario**: 3 puntos de aprobaci√≥n cr√≠ticos
- **Error handling**: Cleanup y mensajes claros en caso de fallo
- **Logging JSONL**: Documentaci√≥n estructurada como /pr

### ü§ñ **Uso de Sub-Agents**
- **code-reviewer**: An√°lisis profesional de issues y recomendaciones  
- **Delegaci√≥n inteligente**: Task tool para an√°lisis especializado
- **Documentaci√≥n**: An√°lisis guardado en `.claude/review/`

### üõ°Ô∏è **Control y Seguridad**
- **Rama temporal obligatoria**: No trabaja en main/develop directamente
- **Aprobaci√≥n en cada fase**: Usuario controla an√°lisis, implementaci√≥n, commit
- **Reversible**: Usuario puede cancelar en cualquier momento
- **Audit trail**: Log completo de todas las decisiones

### üìä **Minimalismo**
- **5 fases claras**: Setup ‚Üí Analysis ‚Üí Control ‚Üí Implementation ‚Üí Logging
- **Sin over-engineering**: Implementaciones targeted, no complejas  
- **Zero dependencies**: Usa herramientas git/gh nativas
- **Single responsibility**: Cada fase tiene un prop√≥sito espec√≠fico

## Flujo de Uso

```bash
# 1. Estar en PR con issues asociados
/pr main                    # Crear PR con temporal branch
/findings-to-issues         # Crear issues desde findings

# 2. Resolver issues de forma controlada
/issues-to-solved          # Nueva versi√≥n mejorada
# ‚Üí Cambia a rama temporal autom√°ticamente
# ‚Üí Delega an√°lisis a code-reviewer  
# ‚Üí Pide aprobaci√≥n antes de implementar
# ‚Üí Commit solo con aprobaci√≥n del usuario
```

**Resultado**: Workflow profesional, controlado y auditado que sigue las mejores pr√°cticas del comando /pr.